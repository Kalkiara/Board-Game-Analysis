---
title: "Modeling"
author: "Maria"
date: "3/19/2024"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
pacman::p_load(tidyverse, patchwork, RColorBrewer, lme4, lmerTest)
```

Run the data cleaning .Rmd script

```{r, warning = FALSE}

file_name <- "Data cleaning.Rmd"
rmarkdown::render(file_name, quiet = TRUE)

rm(file_name)
```

Handle outliers before modeling

```{r}
# function for finding cutoff for outliers
upper_bound <- function(df, rt_term) {
  cutoff <- mean(df[[rt_term]]) + 3 * sd(df[[rt_term]])
  return(cutoff)
}

# list of dataframes 
df_list <- list(df_seed, 
                df_trees, 
                df_tokens, 
                df_gaze,
                df_character,
                df_icon)

# corresponding vector of dataframe names
df_names <- c("df_seed",
              "df_trees", 
              "df_tokens", 
              "df_gaze",
              "df_character",
              "df_icon")

# calculate and store upper bound for each dataframe
upper_bounds <- lapply(df_list, function(df) {
  upper_bound(df, "RT")
})

# function for replacing values exceeding the upper bounds
replace_outliers <- function(df_list, upper_bounds) {
  modified_dfs <- lapply(seq_along(df_list), function(i) {
    df <- df_list[[i]]
    
    # adjust RT values
    df <- df %>%
      mutate(RT = ifelse(
        RT >= upper_bounds[[i]], upper_bounds[[i]], RT)) %>% # replace values exceeding the upper boundary
      
      filter(RT > 0.1) # exclude unrealistically fast response times
    
    return(df)
  })
  
  return(modified_dfs)  # return the list of modified dataframes
}

# call function
modified_dfs_list <- replace_outliers(df_list, upper_bounds)

# loop through the list of modified dfs and assign each dataframe to its original name
for (i in seq_along(modified_dfs_list)) {
  assign(df_names[i], modified_dfs_list[[i]], envir = .GlobalEnv)
}

rm(modified_dfs_list,
   upper_bounds,
   df_names,
   i)

```

Plotting density distributions for response times
```{r}
# define custom color palette for task and manipulation levels
palette <- brewer.pal(n = 12, 
                      name = "Paired")


                  scale_fill_manual(values = c(palette[1], palette[2], 
                                               palette[3], palette[4], 
                                               palette[5], palette[6], 
                                               palette[7], palette[8], 
                                               palette[9], palette[10], 
                                               "peru", palette[12])

```

```{r}
# density plots of the distributions of outcome variables
seed_density <- ggplot(df_seed, aes(x = RT)) +
  geom_density(fill = "skyblue", color = "blue", alpha = 0.7) +
  labs(title = "Seed - Response Time: Density Plot", x = "RT", y = "Density") +
  theme_minimal()

tree_density <- ggplot(df_trees, aes(x = RT)) +
  geom_density(fill = "palegreen2", color = "palegreen4", alpha = 0.7) +
  labs(title = "Trees - Response Time: Density Plot", x = "RT", y = "Density") +
  theme_minimal()

token_density <- ggplot(df_tokens, aes(x = RT)) +
  geom_density(fill = "darkgoldenrod1", color = "darkgoldenrod", alpha = 0.7) +
  labs(title = "Token - Response Time: Density Plot", x = "RT", y = "Density") +
  theme_minimal()

gaze_density <- ggplot(df_gaze, aes(x = RT)) +
  geom_density(fill = "lightpink", color = "lightpink4", alpha = 0.7) +
  labs(title = "Gaze - Response Time: Density Plot", x = "RT", y = "Density") +
  theme_minimal()

character_density <- ggplot(df_character, aes(x = RT)) +
  geom_density(fill = "aquamarine", color = "aquamarine4", alpha = 0.7) +
  labs(title = "Character - Response Time: Density Plot", x = "RT", y = "Density") +
  theme_minimal()

icon_density <- ggplot(df_icon, aes(x = RT)) +
  geom_density(fill = "plum", color = "plum4", alpha = 0.7) +
  labs(title = "Icon - Response Time: Density Plot", x = "RT", y = "Density") +
  theme_minimal()

# plot using patchwork
density_response_times <- 
  (seed_density+tree_density)/
  (token_density+gaze_density)/
  (character_density+icon_density)

density_response_times

rm(seed_density,
   tree_density,
   token_density,
   gaze_density,
   character_density,
   icon_density)
```

Log-transforming does not produce sufficient normality. Instead attempting generalized modeling approaches.
Save density plot as png:

```{r}
# specify dimensions of saved image
width <- 1000  
height <- 650 

png(filename = "../out/RT_density.png", width = width, height = height)
density_response_times

dev.off()
```

Modeling: Task with seed tokens

```{r}

# Define GLMMs with logit link function
seed_m1 <- glmer(RT ~ 1 + manipulation + age + gender + (1 | id),
                 data = df_seed,
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1000000)))

seed_m2 <- glmer(RT ~ 1 + manipulation + age + gender + board_color + (1 | id), 
                 data = df_seed, 
                 family = inverse.gaussian(link = "identity"))

seed_m3 <- glmer(RT ~ 1 + manipulation + age + gender + trials_seeds.thisN + (1 | id), 
                 data = df_seed, 
                 family = inverse.gaussian(link = "identity"))

seed_m4 <- glmer(RT ~ 1 + manipulation + age + gender + board_color + trials_seeds.thisN + (1 | id), 
                 data = df_seed, 
                 family = inverse.gaussian(link = "identity"))
# 
# seed_m5 <- glmer(RT ~ 1 + manipulation + age + gender + trials_seeds.thisN + correctSeednumber + (1 | id),
#                  data = df_seed,
#                  family = inverse.gaussian(link = "identity"),
#                  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 1000000)))

seed_m5 <- glmer(RT ~ 1 + manipulation + age + gender + board_color + trials_seeds.thisN + correctSeednumber + (1 | id),
                 data = df_seed,
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

# seed_m6 <- glmer(RT ~ 1 + manipulation + age + gender + trials_seeds.thisN + played_photo + (1 | id), 
#                  data = df_seed, 
#                  family = inverse.gaussian(link = "identity"))

seed_m6 <- glmer(RT ~ 1 + manipulation + age + gender + board_color + trials_seeds.thisN + played_photo + (1 | id), 
                 data = df_seed, 
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

seed_m7 <- glmer(RT ~ 1 + manipulation + age + gender + trials_seeds.thisN + freq_game + (1 | id), 
                 data = df_seed, 
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))


```

modeling: Task with tree colors

```{r}

# basic models
tree_m1 <- glmer(RT ~ 1 + manipulation + age + gender + (1 | id), 
                 data = df_trees, 
                 subset = tree_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"))

tree_m2 <- glmer(RT ~ 1 + manipulation + age + gender + color_trees_to_count + (1 | id), 
                 data = df_trees, 
                 subset = tree_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

# controlling for stimulus order and which key was pressed
tree_m3 <- glmer(RT ~ 1 + manipulation + age + gender + trials_tree.thisN + (1 | id), 
                 data = df_trees, 
                 subset = tree_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"))

tree_m4 <- glmer(RT ~ 1 + manipulation + age + gender + color_trees_to_count + trials_tree.thisN + (1 | id), 
                 data = df_trees, 
                 subset = tree_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

tree_m5 <- glmer(RT ~ 1 + manipulation + age + gender + trials_tree.thisN + correctTreenumber + (1 | id), 
                 data = df_trees, 
                 subset = tree_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

tree_m6 <- glmer(RT ~ 1 + manipulation + age + gender + color_trees_to_count + trials_tree.thisN + correctTreenumber + (1 | id), 
                 data = df_trees, 
                 subset = tree_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

# controlling for having played the game
tree_m7 <- glmer(RT ~ 1 + manipulation + age + gender + trials_tree.thisN + played_photo + (1 | id), 
                 data = df_trees, 
                 subset = tree_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"))

tree_m8 <- glmer(RT ~ 1 + manipulation + age + gender + color_trees_to_count + trials_tree.thisN + played_photo + (1 | id), 
                 data = df_trees, 
                 subset = tree_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

# controlling for frequency of gaming
tree_m9 <- glmer(RT ~ 1 + manipulation + age + gender + trials_tree.thisN + freq_game + (1 | id), 
                 data = df_trees, 
                 subset = tree_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

```

modeling: Task with token symbols

```{r}
# basic models
token_m1 <- glmer(RT ~ 1 + manipulation + age + gender + (1 | id), 
                  data = df_tokens, 
                  subset = token_resp.corr == "1", 
                  family = inverse.gaussian(link = "identity"))

token_m2 <- glmer(RT ~ 1 + manipulation + age + gender + token_color + (1 | id), 
                  data = df_tokens, 
                  subset = token_resp.corr == "1", 
                  family = inverse.gaussian(link = "identity"))

# controlling for stimulus order and which key was pressed
token_m3 <- glmer(RT ~ 1 + manipulation + age + gender + trials_tokens.thisN + (1 | id), 
                  data = df_tokens, 
                  subset = token_resp.corr == "1", 
                  family = inverse.gaussian(link = "identity"))

token_m4 <- glmer(RT ~ 1 + manipulation + age + gender + token_color + trials_tokens.thisN + (1 | id), 
                  data = df_tokens, 
                  subset = token_resp.corr == "1", 
                  family = inverse.gaussian(link = "identity"))

token_m5 <- glmer(RT ~ 1 + manipulation + age + gender + trials_tokens.thisN + correct_token_options + (1 | id), 
                  data = df_tokens, 
                  subset = token_resp.corr == "1", 
                  family = inverse.gaussian(link = "identity"),
                  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

# controlling for having played the game
token_m6 <- glmer(RT ~ 1 + manipulation + age + gender + trials_tokens.thisN + played_haven + (1 | id), 
                  data = df_tokens, 
                  subset = token_resp.corr == "1", 
                  family = inverse.gaussian(link = "identity"))

token_m7 <- glmer(RT ~ 1 + manipulation + age + gender + token_color + trials_tokens.thisN + played_haven + (1 | id), 
                  data = df_tokens, 
                  subset = token_resp.corr == "1", 
                  family = inverse.gaussian(link = "identity"))

# controlling for frequency of gaming
token_m8 <- glmer(RT ~ 1 + manipulation + age + gender + trials_tokens.thisN + freq_game + (1 | id), 
                  data = df_tokens, 
                  subset = token_resp.corr == "1", 
                  family = inverse.gaussian(link = "identity"),
                  control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

```

modeling: Task with gaze direction

```{r}
# basic models
gaze_m1 <- glmer(RT ~ 1 + manipulation + age + gender + (1 | id), 
                 data = df_gaze, 
                 subset = gaze_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"))

gaze_m2 <- glmer(RT ~ 1 + manipulation + age + gender + stimulus_type + (1 | id), 
                 data = df_gaze, 
                 subset = gaze_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

# controlling for stimulus order, stimulus type, and/or which key was pressed
gaze_m3 <- glmer(RT ~ 1 + manipulation + age + gender + trials_gaze.thisN + (1 | id), 
                 data = df_gaze, 
                 subset = gaze_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"))

gaze_m4 <- glmer(RT ~ 1 + manipulation + age + gender + stimulus_type + trials_gaze.thisN + (1 | id), 
                 data = df_gaze, 
                 subset = gaze_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

gaze_m5 <- glmer(RT ~ 1 + manipulation + age + gender + trials_gaze.thisN + correctGazeanswer + (1 | id), 
                 data = df_gaze, 
                 subset = gaze_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

# controlling for having played the game
gaze_m6 <- glmer(RT ~ 1 + manipulation + age + gender + trials_gaze.thisN + played_tang + (1 | id), 
                 data = df_gaze, 
                 subset = gaze_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"))

gaze_m7 <- glmer(RT ~ 1 + manipulation + age + gender + stimulus_type + trials_gaze.thisN + played_tang + (1 | id), 
                 data = df_gaze, 
                 subset = gaze_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

# controlling for frequency of gaming
gaze_m8 <- glmer(RT ~ 1 + manipulation + age + gender + trials_gaze.thisN + freq_game + (1 | id), 
                 data = df_gaze, 
                 subset = gaze_response.corr == "1", 
                 family = inverse.gaussian(link = "identity"),
                 control = glmerControl(optimizer = "bobyqa", optCtrl = list(maxfun = 100000)))

```

modeling: Task with icon matching 


Two-part model specification starting with modeling the fixed effects, based on the following issue on gitHub: https://github.com/lme4/lme4/issues/573

```{r, message=FALSE}
# basic models
icon_m1_fixef <- glm(RT ~ 1 + manipulation + age + gender, 
          data = df_icon,
          subset = icon_resp.corr == "1", 
          family = Gamma(link = "identity"))

icon_m1 <- glmer(RT ~ 1 + manipulation + age + gender + (1 | id), 
            data = df_icon,
            subset = icon_resp.corr == "1", 
            family = Gamma(link = "identity"),
            start = list(fixef=coef(icon_m1_fixef)),
            control = glmerControl(nAGQ0initStep=FALSE),
            verbose = 100)

# controlling for stimulus order 
icon_m2_fixef <- glm(RT ~ 1 + manipulation + trials.thisN,
          data = df_icon,
          subset = icon_resp.corr == "1",
          family = Gamma(link = "identity"))

icon_m2 <- glmer(RT ~ 1 + manipulation + trials.thisN + (1 | id),
                 data = df_icon,
                 subset = icon_resp.corr == "1",
                 family = inverse.gaussian(link = "identity"),
                 start = list(fixef=coef(icon_m2_fixef)),
                 control = glmerControl(optimizer = "bobyqa", nAGQ0initStep=FALSE, optCtrl = list(maxfun = 100000)),
                 verbose = 100)

# icon_m3_fixef <- glm(RT ~ 1 + manipulation + trials.thisN + gender + age,
#           data = df_icon,
#           subset = icon_resp.corr == "1",
#           family = Gamma(link = "identity"))
# 
# icon_m3 <- glmer(RT ~ 1 + manipulation + trials.thisN + gender + age + (1 | id),
#                  data = df_icon,
#                  subset = icon_resp.corr == "1",
#                  family = inverse.gaussian(link = "identity"),
#                  start = list(fixef=coef(icon_m3_fixef)),
#                  control = glmerControl(optimizer = "bobyqa", nAGQ0initStep=FALSE, optCtrl = list(maxfun = 100000)),
#                  verbose = 100)

```

modeling: Task with character matching

```{r}
# basic models
character_m1 <- glmer(RT ~ 1 + manipulation + age + gender + (1 | id), 
                      data = df_character, 
                      subset = character_resp.corr == "1", 
                      family = inverse.gaussian(link = "identity"))

character_m2 <- glmer(RT ~ 1 + manipulation + age + gender + character_type + (1 | id), 
                      data = df_character, 
                      subset = character_resp.corr == "1", 
                      family = inverse.gaussian(link = "identity"))

# controlling for stimulus order 
character_m3_fixef <- glm(RT ~ 1 + manipulation + trials_character.thisN, 
          data = df_character,
          subset = character_resp.corr == "1", 
          family = Gamma(link = "identity"))

character_m3 <- glmer(RT ~ 1 + manipulation + trials_character.thisN + (1 | id),
            data = df_character,
            subset = character_resp.corr == "1",
            family = Gamma(link = "identity"),
            start = list(fixef=coef(character_m3_fixef)),
            control = glmerControl(optimizer = "bobyqa", nAGQ0initStep=FALSE, optCtrl = list(maxfun = 100000)),
            verbose = 100)

```

Model selection

```{r}
# make function for assessing AIC and BIC for various model fits

model_selection <- function(
  naming_scheme, 
  number_of_models) {

# generate model names
model_names <- paste0(naming_scheme, 1:number_of_models)

# create a list with the model names
model_list <- lapply(model_names, function(name) get(name))

# assign names to the elements in the list
names(model_list) <- model_names

# function to extract AIC and BIC values from fitted models
get_AIC_BIC <- function(model) {
  
  AIC_val <- AIC(model)
  BIC_val <- BIC(model)
  
  return(c(AIC_val, 
           BIC_val))
}

# apply the function to each model in the list
AIC_BIC_values <- sapply(model_list, get_AIC_BIC)

# creat table for easy overview
table <- data.frame(AIC = AIC_BIC_values[1, ], 
                    BIC = AIC_BIC_values[2, ])

return(table)

}

# apply the function to each of the tasks/investigations
seed_model_selection <- model_selection("seed_m", 7) 
tree_model_selection <- model_selection("tree_m", 9) 
token_model_selection <- model_selection("token_m", 8) 
gaze_model_selection <- model_selection("gaze_m", 8) 
icon_model_selection <- model_selection("icon_m", 2) 
character_model_selection <- model_selection("character_m", 3) 

```

Clean up environment after deciding on which models to go with. For all models, this is assessed manually by looking at AIC and BIC values.


     - chosen models: character_m3, gaze_m4, icon_m2, seed_m5, token_m5, tree_m6
      
```{r}
# variables to keep
variables_to_keep <- c("df_character", "df_gaze", "df_icon", "df_seed", "df_tokens", "df_trees",
                       
                       "character_model_selection", "gaze_model_selection", 
                       "icon_model_selection", "seed_model_selection", 
                       "token_model_selection", "tree_model_selection",
                       
                       "character_m3", "gaze_m4", "icon_m2",
                       "seed_m5", "token_m5", "tree_m6",
                       
                       "character_m3_fixef", "icon_m2_fixef",
                       
                       "df_list")

# remove all variables except those in the list
rm(list = setdiff(ls(), variables_to_keep))

```

Residual plotting

```{r}
# list of selected models
models <- list(
  
  character = character_m3,
  gaze = gaze_m4,
  icon = icon_m2,
  seed = seed_m5,
  token = token_m5,
  tree = tree_m6
)


# function to create residual plots 
create_residual_plot <- function(model, 
                                 model_name) {
  
  # extract residuals and fitted values
  residuals <- resid(model)
  fitted_values <- fitted(model)
  residual_data <- data.frame(Residuals = residuals, 
                              Fitted_Values = fitted_values)
  
  # plot 
  ggplot(residual_data, aes(x = Fitted_Values, y = Residuals)) +
    geom_point(color = "blue", 
               alpha = 0.7) +
    geom_hline(yintercept = 0, 
               linetype = "dashed", 
               color = "red") +
    labs(title = "Residuals vs Fitted Values", 
         subtitle = paste("Model:", model_name), 
         x = "Fitted Values", 
         y = "Residuals") +
    theme_minimal()
}

# make plots for each model
plots <- lapply(names(models), function(model_name) {
  create_residual_plot(models[[model_name]], model_name)
})

# arrange plots in grid
wrap_plots(plots)


```

Save plot as png

```{r}
# specify dimensions of saved image
width <- 1500  
height <- 960 

png(filename = "../out/residuals.png", width = width, height = height)
wrap_plots(plots)

dev.off()
```

View summaries

```{r}
# view summaries of all models
for (i in seq_along(models)) {
  cat("Model", i, "summary:\n")
  print(summary(models[[i]]))
}

```

Save summary output

```{r}
# open connection to save output as text file
sink("../out/model_summaries.txt")

# run same code as in above chunk
for (i in seq_along(models)) {
  cat("Model", i, "summary:\n")
  print(summary(models[[i]]))
}

# close the connection
sink()
```

Plot differences


```{r}
# select specific columns from each dataframe
df_seed_subset <- df_seed[, c("RT", "manipulation")] %>%
  mutate(task = "Investigation 2")
df_tokens_subset <- df_tokens[, c("RT", "manipulation")] %>%
  mutate(task = "Investigation 4")
df_character_subset <- df_character[, c("RT", "manipulation")] %>%
  mutate(task = "Investigation 1")
df_gaze_subset <- df_gaze[, c("RT", "manipulation")] %>%
  mutate(task = "Investigation 5")
df_icon_subset <- df_icon[, c("RT", "manipulation")] %>%
  mutate(task = "Investigation 6")
df_trees_subset <- df_trees[, c("RT", "manipulation")] %>%
  mutate(task = "Investigation 3")

# combine the selected columns
plotting_df <-
  rbind(
    df_seed_subset,
    df_tokens_subset,
    df_character_subset,
    df_gaze_subset,
    df_icon_subset,
    df_trees_subset
  ) 


# define custom color palette for task and manipulation levels
palette <- brewer.pal(n = 12, 
                      name = "Paired")

custom_labels <- c("seed matching","tokens matching", "character matching", "gaze matching", "icon matching", "trees matching")

# violin plot 
violins <- ggplot(plotting_df, 
                  aes(x = manipulation, y = RT, fill = interaction(manipulation, task))) +
                  geom_violin(color = "black", size = 0.5, width = 0.7) +  
                  geom_boxplot(width = 0.1, fill = "white", color = "black", alpha = 0.5, outlier.shape = NA) + 
                  labs(x = "Manipulation", y = "Response Time") +  
                  facet_wrap(~ task, scales = "free") + 
                  scale_fill_manual(values = c(palette[1], palette[2], 
                                               palette[3], palette[4], 
                                               palette[5], palette[6], 
                                               palette[7], palette[8], 
                                               palette[9], palette[10], 
                                               "peru", palette[12]),
                                     name = "Investigation") +  
                  theme_minimal() 
                  
violins    

```

Save violin plot

```{r}
# specify dimensions of saved image
# width <- 1000  
# height <- 800 
width <- 3000
height <- 2400

png(filename = "../out/violin_plot.png", width = width, height = height)
violins +
  theme(strip.text = element_text(size = 45),  # facet labels
        axis.text.x = element_text(size = 40), # axis text
        axis.text.y = element_text(size = 40),
        axis.title.x = element_text(size = 45), # axis labels
        axis.title.y = element_text(size = 45),
        legend.position = "none") 

dev.off()
```



